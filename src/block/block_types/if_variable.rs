use either :: Either ; use crate :: types :: * ; pub enum IfVariable { Number { number_to_check : Number , number_to_compare_to : Number } , DictionaryValueEquals { dictionary_to_check : Dict , key_to_check : Text , values_to : Vec < AnyType > } , ItemHasCustomTag { item_to_check : Item , tag_name : Text , tag_value : Option < Either < Number , Text > > } , StringMatches { string_or_source_expression_to_match : Text , string_to_compare : Vec < Text > } , StringStartsWith { string_to_check : Text , string_to_start_with : Vec < Text > } , ListValueEquals { list_to_check_in : List , index_to_check_at : Number , variable_to : Vec < AnyType > } , ValueIsType { value_to_check : AnyType } , TextMatches { } , IsNear { } , ValueIsWithinRange { check_value : AnyType , minimum_value : AnyType , maximum_value : AnyType } , VariableExists { variable_to_check : Variable } , LegacyEq { } , ItemEquals { item_to_check : Item , items_to_compare_to : Vec < Item > } , ListContainsValue { list_to_check_in : List , value_to_find : Vec < AnyType > } , LegacyEqN { } , InRange { } , LocationIsNear { location_to_check : Location , locations_to : Vec < Location > , radius : Number } , StringContains { string_to_check : Text , string_to_check_for : Vec < Text > } , ValueEq { value_to_check : AnyType , values_to_compare_to : Vec < AnyType > } , NumberLessThan { number_to_check : Number , number_to_compare_to : Number } , Eq { value_to_check : AnyType , values_to_compare_to : Vec < AnyType > } , NumberGreaterThan { number_to_check : Number , number_to_compare_to : Number } , StringEndsWith { string_to_check : Text , string_to_end_with : Vec < Text > } , GreaterThanEq { number_to_check : Number , number_to_compare_to : Number } , DictionaryHasKey { dictionary_to_check : Dict , key_to_look_for : Text } , }